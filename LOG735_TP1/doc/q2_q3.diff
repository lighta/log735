diff -ur ../src/main/java/ens/etsmtl/ca/q2/Client.java ../src/main/java/ens/etsmtl/ca/q3/Client.java
--- ../src/main/java/ens/etsmtl/ca/q2/Client.java	2015-05-12 19:02:33.955809659 -0400
+++ ../src/main/java/ens/etsmtl/ca/q3/Client.java	2015-05-12 19:02:33.952809594 -0400
@@ -1,54 +1,282 @@
-package ens.etsmtl.ca.q2;
-
-import java.io.*;
-import java.net.*;
-
-public class Client {
-	public static void main(String[] args) throws IOException {
-
-		String serverHostname = new String("127.0.0.1");
-
-		if (args.length > 0)
-			serverHostname = args[0];
-		System.out.println("Essai de se connecter à l'hôte " + serverHostname
-				+ " au port 10118.");
-
-		Socket echoSocket = null;
-		PrintWriter out = null;
-		BufferedReader in = null;
-
-		try {
-			echoSocket = new Socket(serverHostname, 10118);
-			out = new PrintWriter(echoSocket.getOutputStream(), true);
-			in = new BufferedReader(new InputStreamReader(
-					echoSocket.getInputStream()));
-		} catch (UnknownHostException e) {
-			System.err.println("Hôte inconnu: " + serverHostname);
-			System.exit(1);
-		} catch (IOException e) {
-			System.err.println("Ne pas se connecter au serveur: "
-					+ serverHostname);
-			System.exit(1);
-		}
-
-		BufferedReader stdIn = new BufferedReader(new InputStreamReader(
-				System.in));
-		String userInput;
-		System.out.print("Entrée: ");
-		while ((userInput = stdIn.readLine()) != null) {
-			out.println(userInput);
-			String echo = in.readLine();
-			System.out.println("echo: " + echo);
-			if (echo.contains("BYE")) {
-				break;
-			}
-
-			System.out.print("Entrée: ");
-		}
-
-		out.close();
-		in.close();
-		stdIn.close();
-		echoSocket.close();
-	}
-}
+package ens.etsmtl.ca.q3;
+
+import java.io.*;
+import java.net.*;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+
+
+public class Client {
+	private Socket echoSocket = null;
+	private PrintWriter out = null;
+	private BufferedReader in;
+	int current = -1;
+	
+	private enum state_echo {
+		END,  //fin de connection par server
+		NEXT, //prochaine demande du client
+		TIMEOUT; //timeout atteint, faire strat
+	};
+	
+	final int TIMEOUT = 3000; // 3 seconds
+	private ScheduledExecutorService executor;
+	
+	private class EchoHandler extends Thread
+	{
+		
+		private BufferedReader in;
+
+		public EchoHandler(BufferedReader in) {
+			this. in = in;
+		}
+		
+		@Override
+		public void run() {
+			try {
+				String echo = in.readLine();
+				System.out.println("echo: " + echo);
+				if (echo.contains("BYE")) {
+						
+				}
+			} catch (IOException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+
+		}
+	}
+	
+	
+	private class ServerDico {
+
+		@SuppressWarnings("unused")
+		protected String host_name = "";
+		@SuppressWarnings("unused")
+		protected int port = 10118;
+
+		@SuppressWarnings("unused")
+		public ServerDico(String host_name, int port) {
+			this(host_name);
+			this.port = port;
+		}
+
+		public ServerDico(String host_name) {
+			this.host_name = host_name;
+		}
+	}
+
+	private final Map<Integer, ServerDico> servers_dico = new HashMap<>();
+
+	private final void FillServerDico() {
+		servers_dico.put(0, new ServerDico("127.0.0.1"));
+		servers_dico.put(1, new ServerDico("127.0.0.2"));
+	}
+
+	private ServerDico getNext_host() {
+		current++;
+		if (current >= servers_dico.size() ) {
+			System.err.println("Plus de serveur disponible pour switch");
+			System.exit(1);
+		}
+		return servers_dico.get(current);
+	}
+
+	private Socket attempt_to_connect() {
+		return attempt_to_connect(null, null);
+	}
+
+	private boolean init_sock(String hostname, Integer port, boolean switch_host) {
+		if(switch_host){
+			if (echoSocket != null){
+				try {
+					echoSocket.close();
+				} catch (IOException e) {
+					System.err.println("Couldn't close socket");
+				}
+			}	
+		}
+		echoSocket = attempt_to_connect(hostname, port);
+		if (echoSocket == null) {
+			System.out.println("Aucun serveur dispo");
+			return false;
+		//	System.exit(2);
+		}
+		try {
+			out = new PrintWriter(echoSocket.getOutputStream(), true);
+		} catch (IOException e) {
+			System.err.println("Couldn't attach to outSocket");
+			return false;
+		//	e.printStackTrace();
+		}
+		try {
+			in = new BufferedReader(new InputStreamReader(echoSocket.getInputStream()));
+		} catch (IOException e) {
+			System.err.println("Couldn't attach to outSocket");
+			return false;
+		//	e.printStackTrace();
+		}
+		
+		return true;
+	}
+	
+	private Socket attempt_to_connect(String hostname, Integer port) {
+		Socket tmp_Socket = null;
+		String serverHostname = "";
+		int server_port = 10118;
+		ServerDico hostserv;
+		final int TIMEOUT_CONNECT = 3000; // 3s ot connect
+
+		
+		System.out.println("current="+current);
+		if (hostname != null) {
+			serverHostname = hostname;
+			if (port != null) { //on ne prend pas le port si on a pas de hostname associer
+				server_port = port;
+			}
+		} else {
+			hostserv = getNext_host();
+			serverHostname = hostserv.host_name;
+			server_port = hostserv.port;
+		}
+		
+		while (true) {
+			if(echoSocket != null){ //check if already used
+				if(echoSocket.getInetAddress().getHostAddress().compareToIgnoreCase(serverHostname)==0){
+					System.out.println("Same host");
+					if(echoSocket.getPort() == server_port){
+						System.out.println("And same port, skipping...");
+						//getting next (is skipping)
+						hostserv = getNext_host();
+						serverHostname = hostserv.host_name;
+						server_port = hostserv.port;
+					}
+				}
+			}
+			try {
+				System.out.println("Essai de se connecter a l'hote "+ serverHostname + " au port " + server_port);
+				tmp_Socket = new Socket();
+				tmp_Socket.connect(new InetSocketAddress(serverHostname,server_port), TIMEOUT_CONNECT);
+				break; //on a trouver un serveur valide, on sort
+			} catch (UnknownHostException e) {
+				System.err.println("Hote inconnu: " + serverHostname);
+			} catch (IOException e) {
+				System.err.println("Ne peut pas se connecter au serveur: "+ serverHostname);
+			}
+			hostserv = getNext_host();
+			serverHostname = hostserv.host_name;
+			server_port = hostserv.port;
+		}
+
+		return tmp_Socket;
+	}
+
+	//@TODO, faire le retrun du call return de la fonction lauch
+	private state_echo launch(BufferedReader in) throws IOException {	
+		final BufferedReader tmp_in = in;
+		state_echo res = state_echo.NEXT;
+
+		
+		final Future<state_echo> handler = executor.submit(new Callable<state_echo>() {
+		    @Override
+		    public state_echo call() throws Exception {
+		    	String echo = tmp_in.readLine();
+		    	state_echo res;
+				System.out.println("echo: " + echo);
+				if (echo.contains("BYE")) {
+					res = state_echo.END;
+				}
+				else {
+					res = state_echo.NEXT;
+				}
+				executor.shutdownNow();
+				return res;
+		    }
+		});
+		try {
+			executor.schedule(new Runnable(){
+			    @Override
+			    public void run(){
+			    	System.out.println("Canceling job");
+			        handler.cancel(true);
+			        System.out.println("Cancel done");
+			        executor.shutdown();
+			        //state_echo.TIMEOUT;
+			    }      
+			}, TIMEOUT, TimeUnit.MILLISECONDS);
+		}
+		catch (RejectedExecutionException rj){
+			if(handler.isDone() == false ){
+				System.out.println("Error with scheduling timeout");
+			}	
+		}
+
+		while(!handler.isDone()); // on attend
+		
+		if(handler.isCancelled()) {
+			return state_echo.TIMEOUT;
+		}
+		try {
+			return handler.get();
+		} catch (InterruptedException e) {
+			return state_echo.TIMEOUT;
+		} catch (ExecutionException e) {
+			System.err.println("Erreur quelque part dans le thread.. veuillez recommencez !!");
+			return state_echo.NEXT; //on reeesaye une nouvelle entree de client
+		}
+	}
+	
+	
+	
+	//@TODO gere les IOexcept
+	public Client() throws IOException {
+		FillServerDico();
+
+		BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));
+		System.out.println("Entrez l'ip du serveur");
+		String serverHostname = stdIn.readLine();
+
+		if(init_sock(serverHostname, null,false)==false)
+			System.exit(2);
+		
+		String userInput="";
+		boolean getinput = true;
+		System.out.print("Entree: ");
+
+		while (true) {
+			if(getinput==true)
+				userInput = stdIn.readLine();
+			getinput=true;
+			
+			out.println(userInput); 
+			executor = Executors.newScheduledThreadPool(2);
+			final state_echo res = launch(in);
+			if(res == state_echo.END) break;
+			else if(res == state_echo.TIMEOUT){
+				System.out.println("Timeout reached, need to switch host");
+				if(init_sock(null,null,true)==false)
+					System.exit(2);
+				getinput=false;
+				//ok mais est-ce qu'on refait cette putin de requete ??
+			}
+			System.out.print("Entree: ");
+		}
+		stdIn.close();
+		
+		out.close();
+		in.close();
+		echoSocket.close();
+	}
+
+	//@TODO remove throw from main
+	public static void main(String[] args) throws IOException {
+		new Client();
+	}
+}
diff -ur ../src/main/java/ens/etsmtl/ca/q2/Server.java ../src/main/java/ens/etsmtl/ca/q3/Server.java
--- ../src/main/java/ens/etsmtl/ca/q2/Server.java	2015-05-12 19:02:33.956809680 -0400
+++ ../src/main/java/ens/etsmtl/ca/q3/Server.java	2015-05-12 19:02:33.955809659 -0400
@@ -1,87 +1,111 @@
-package ens.etsmtl.ca.q2;
-
-
-import java.net.*;
-import java.io.*;
-
-public class Server {
-
-	static boolean run = true;
-
-	public static class HandlerTCP extends Thread {
-		Socket clientSocket = null;
-
-		public HandlerTCP(Socket clientSocket) throws IOException {
-			this.clientSocket = clientSocket;
-		}
-
-		private void reply() throws IOException {
-			PrintWriter out;
-			out = new PrintWriter(clientSocket.getOutputStream(), true);
-			BufferedReader in = new BufferedReader(new InputStreamReader(
-					clientSocket.getInputStream()));
-
-			String inputLine;
-			while ((inputLine = in.readLine()) != null) {
-				inputLine = inputLine.toUpperCase();
-				//echo + bye
-				if (inputLine.equalsIgnoreCase("Bye")){
-					out.println(inputLine+" : Connection closed");
-					System.out.println("Serveur: Connection client closed" );
-					break;
-				}
-				//echo standard
-				System.out.println("Serveur: " + inputLine);
-				out.println(inputLine);
-			}
-			
-			out.close();
-			in.close();
-		}
-
-		@Override
-		public void run() {
-			System.out.println("connexion réussie");
-			System.out.println("Attente de l'entrée.....");
-			try {
-				reply();
-			} catch (IOException e) {
-				System.err.println("Reply failed");
-				// e.printStackTrace();
-			}
-			try {
-				clientSocket.close();
-			} catch (IOException e) {
-				System.err.println("Closed failed");
-				// e.printStackTrace();
-			}
-		}
-	}
-
-	public static void main(String[] args) throws IOException {
-		Socket clientSocket = null;
-		ServerSocket serverSocket = null;
-
-		try {
-			serverSocket = new ServerSocket(10118);
-			System.out.println("Le serveur est en marche, Attente de la connexion...");
-			while (run == true) {
-				try {
-					clientSocket = serverSocket.accept();
-				} catch (IOException e) {
-					System.err.println("Accept a échoué... next");
-					//System.exit(1);
-				}
-				HandlerTCP clientjob = new HandlerTCP(clientSocket);
-				clientjob.start();
-			}
-		} catch (IOException e) {
-			System.err.println("On ne peut pas écouter au  port: 10118.");
-			System.exit(1);
-		}
-		finally {
-			serverSocket.close();
-		}
-
-	}
-}
+package ens.etsmtl.ca.q3;
+
+import java.net.*;
+import java.io.*;
+
+public class Server {
+	static boolean run = true;
+	static int second=5;
+
+	public static class HandlerTCP extends Thread {
+		Socket clientSocket = null;
+
+		public HandlerTCP(Socket clientSocket) throws IOException {
+			this.clientSocket = clientSocket;
+		}
+
+		private void reply() throws IOException, InterruptedException {
+			PrintWriter out;
+			out = new PrintWriter(clientSocket.getOutputStream(), true);
+			BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
+
+			
+			String inputLine;
+			while ((inputLine = in.readLine()) != null) {
+				System.out.println("Serveur waiting for : " + second);
+				Thread.sleep(1000*second);
+				System.out.println("Sleep ended");
+				inputLine = inputLine.toUpperCase();
+				//echo + bye
+				if (inputLine.equals("BYE")){
+					out.println(inputLine+" : Connection closed");
+					System.out.println("Serveur: Connection client closed" );
+					break;
+				}
+				//echo standard
+				System.out.println("Serveur: " + inputLine);
+				out.println(inputLine);
+			}
+			
+			out.close();
+			in.close();
+		}
+
+		@Override
+		public void run() {
+			System.out.println("connexion reussie");
+			System.out.println("Attente de l'entree.....");
+			try {
+				reply();
+			} catch (IOException e) {
+				System.err.println("Reply failed");
+				// e.printStackTrace();
+			} catch (InterruptedException e) {
+				// TODO Auto-generated catch block
+				e.printStackTrace();
+			}
+			try {
+				clientSocket.close();
+			} catch (IOException e) {
+				System.err.println("Closed failed");
+				// e.printStackTrace();
+			}
+		}
+	}
+
+	public static void main(String[] args) throws IOException {
+		
+		Socket clientSocket = null;
+		ServerSocket serverSocket = null;
+		InetAddress ipAddress;
+		String inputLine = "";
+
+		
+		BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in));
+		System.out.println("Entrez l'ip de bind du serveur");
+		inputLine = stdIn.readLine();
+		//check ip
+		ipAddress= InetAddress.getByName(inputLine);
+		
+		System.out.println("Entrez le nb de second");
+		inputLine = stdIn.readLine();
+		second = Integer.parseInt(inputLine);
+		
+		try {
+			serverSocket = new ServerSocket(10118,0, ipAddress);
+		} catch (IOException e) {
+			System.err.println("On ne peut pas ecouter au  port: 10118.");
+			System.exit(1);
+		}
+		finally {
+			System.out.println("Le serveur est en marche, Attente de la connexion...");
+			
+	
+			while (run == true) {
+	
+				try {
+					clientSocket = serverSocket.accept();
+				} catch (IOException e) {
+					System.err.println("Accept a echoue.");
+					System.exit(1);
+				}
+	
+				HandlerTCP clientjob = new HandlerTCP(clientSocket);
+				clientjob.start();
+	
+			}
+			serverSocket.close();
+		}
+
+	}
+}
\ No newline at end of file
